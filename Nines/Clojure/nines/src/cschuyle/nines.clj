(ns cschuyle.nines
  (:require [clojure.set :as set]
            [clojure.math.numeric-tower :as math]))

(defn combinations
  "Returns all combinations (unordered pairs) of integers which are >0
  <n, which sum to n."
  [n]
  (let [half-n (inc (math/floor (/ n 2)))]
    (map (fn [x] [x (- n x)]) (range 1 half-n))))

(defn permutations
  "Returns all combinations (ordered pairs) of integers which are >0
  <n, which sum to n."
  [n]
  (map (fn [x] [x (- n x)]) (range 1 n)))

(defn commutative? [operator]
  (#{+ *} operator))

(defn combos-for
  [operator n]
  (if (commutative? operator) (combinations n) (permutations n)))

(defn crossproduct
  "Returns the cross-product (cartesian product) of set a and set b,
  using the supplied arithmetic operator."
  [operator set-a set-b]
  (into #{} (filter identity ;; no nils! - those are the division-by-zeros
                    (for [a set-a
                          b set-b]
                      (operator a b)))))

(defn- div
  "Safe division: Returns nil on divide-by-zero"
  [num den]
  (if (= 0 den) nil (/ num den)))

(def order
  "Return the set of values generated by all expressions containing n
  nines.  Memoized for your pleasure."
  (memoize
   (fn [n]
     (if (= 1 n)
       #{9}
       (apply set/union (for [operator [+ - * div]
                              [a b]    (combos-for operator n)]
                          (crossproduct operator (order a) (order b))))))))

(def natural-numbers
  "Infinite sequence of natural numbers (integers >0)"
  (lazy-cat [1] (map inc natural-numbers)))

(defn solve
  "With no arguments, solves the Nines problem with nine nines.
  With the argument n, solves it with n nines."
  ([] (solve 9))
  ([n]
     (some #(when (not (contains? (order n) %))
              %)
           natural-numbers)))
