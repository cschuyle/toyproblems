(ns cschuyle.nines
  (:require [clojure.set :as set]))

(defn combinations
  "Returns all combinations (pairs) of integers which are >0 <n, which sum to n."
  [n]
  (map (fn [x] [x (- n x)]) (range 1 n)))

(defn crossproduct
  "Returns the cross-product (cartesian product) of set a and set b,
  using the supplied arithmetic operator (any function can be supplied
  as operator as long as it takes 2 arguments and never throws an
  exception.  Instead of throwin an exception, make it reurn nil)"
  [operator set_a set_b]
  (into #{} (filter identity ;; no nils! - those are the division-by-zeros
                    (for [a set_a
                          b set_b]
                      (operator a b)))))

(defn- div
  "Safe division: Returns nil on divide-by-zero"
  [num den]
  (if (= 0 den) nil (/ num den)))

(def order
  "Return the set of values generated by all expressions containing n
  nines.  Memoized for your pleasure."
  (memoize
   (fn [n]
     (if (= 1 n) #{9}
         (let [crossproducts (for [operator [+ - * div]
                                   [a b]    (combinations n)]
                               (crossproduct operator (order a) (order b)))]
           (apply set/union crossproducts))))))

(def natural-numbers
  "Infinite sequence of natural numbers (integers >0)"
  (lazy-cat [1] (map inc natural-numbers)))

(defn solve
  "With no arguments, solves the Nines problem with nine nines.
  With the argument n, solves it with n nines."
  ([] (solve 9))
  ([n]
     (some #(when (not (contains? (order n) %))
              %)
           natural-numbers)))
