# nines

Solution to the ["Nine Nines" problem](http://members.iinet.net.au/~tmorrow/mathematics/ninenines/ninenines.html)

Or, in case the above link moves:

"Find the least natural number N > 0 such that N is not a solution of any mathematical expression containing the operators +, -, *, /, and exactly nine instances of the number 9.  Only the plain number 9, not numbers containing the digit 9.  i.e., 9 is allowed, not 99, or 9.9.  e.g., one possible expression is:

9 - ((9 * 9) / 9)) + (9 / 9) + 9 - (9 / 9)"

The result happens to be 9 in the above case - that's just a coincidence though.

## Usage

Assuming you are on a bashy shell on a *nixy platform, have Leiningen installed, are connected to the Internets, and the planets are aligned:

`lein run`

The above solves the problem for order 9.  You can solve orders less than 9 (see the link above and/or the ramble below if you don't know what I'm talking about) like this:

`ORDER=4 lein run`

## About my solution

Since a friend of mine and I were gabbing about the solution to this in a shack in Costa Rica a few years back (that's when I first heard of the problem), I've always thought the most straightforward solution was to use dynamic programming, starting with the "order 1" solution (the number 9), then proceed to higher orders.  If you have a cooler solution, I'd love to see it (for example, using a search algorithm to arrive at each natural number starting with 1, then halting with the solution when you can't find one.  The trick would be the search.  Come to think of it, that'd be cool - I'll try that solution next).

In the meantime, here's a brief explanation via demonstration of my admittedly brute-force solution:

For order 2, combine order 1 using all the available operators:

<pre>9 + 9 = 18
9 - 9 = 0
9 * 9 = 81
9 / 9 = 1
</pre>

Now let's call `order2` the union of the values generated by all the above computations, which is {0, 1, 18, 81}.

To talk in terms of variables instead of specific numbers, let's call `order1` = {9} (the set containing the single number 9). For orders greater than 1, let `orderN` be the set of all the numbers generated by expressions containing N 9s.  To compute this, "combine" `orderX` and `orderY` for all X and Y such that X+Y = N.  The solution to the original problem is the lowest I > 0 such that I is not is `order9`.

Now, here's how to get there, continuing by example with N=3. There are only two orders to combine into order 3, since 1+2=3, and _only_ 1 and 2 sum to 3.

<pre>
order1 + order2
order1 * order2
order1 - order2
order2 - order1
order1 / order2
order2 / order1
</pre>

Note that we can take commutativity into account in order to optimize the treatment of the + and * operators (i.e. 2-1 != 1-2; ditto with division, whereas 1+2 = 2+1).

By "combine" above, what I really mean is take the _cross product_ using each operator of the lower orders that are being combined, then take the union of all the resulting sets.

To be more explicit about the algorithm for combining lower orders: Take the union of all cross-products of `orderX` and `orderY`, where X+Y = N, for all operators.  As an optimization, for commutative operators, take the cross products only of _combinations_ of X and Y.  For non-commutative operators, take the cross products of _permutations_.

A final example tying all the above together: here is how to do `order4`:

<pre>
UNION(
  CROSSPRODUCT(+, order1, order3),
  CROSSPRODUCT(+, order2, order3),
  CROSSPRODUCT(*, order1, order3),
  CROSSPRODUCT(*, order2, order3),
  CROSSPRODUCT(-, order1, order3),
  CROSSPRODUCT(-, order2, order2),
  CROSSPRODUCT(-, order3, order1),
  CROSSPRODUCT(/, order1, order3),
  CROSSPRODUCT(/, order2, order2),
  CROSSPRODUCT(/, order3, order1)
)
</pre>

That's really all you need to know to understand the algorithm.  I'll implement this using recursion, memoizing each `orderN` so that higher orders don't have to recompute them (that's the "dynamic programming" part).

One final optimization: We need to keep around all resulting values for intermediate (N<9) computations, but for N=9, we can safely ignore any result which is not a natural number.  This is a memory optimization more than anything else.

One note about the Clojure solution: Since Clojure has built-in rationals, I can just use them, more or less without thinking about it.  For some others languages, using rationals might be a bit more work - but perhaps not using rationals (using floats or doubles instead) would be more performant.  Maybe I'll try both in Clojure and get some performance numbers.

OK!  So now that I've written the solution up, I'm about to start to actually implement it.  Hopefully the code itself will be in many ways more comprehensible than the above.

## License

Copyright Â© 2014 Carlton Schuyler

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
